# Как тестировать главную страницу с кучей связей

- Обращаемся к разным вьюмоделям
- Синхронизируем ожидание
- Усложняем работу с сетью

## Проблемы тестирования главной страницы

В прошлых главах мы разобрались как тестировать отдельные сценарии: тестировали координатор и смотрели как он создает вьюмодели для следующих экранов. При тестировании главной страницы появляются новые сложности:
- Множество координаторов. В приложении нужно протестировать связи между разными модулями: например, мы создали кредит, от чего список транзакций должен показать новый платеж, а баланс обновиться. 
- Множество запросов. Даже просто для первого отображения экрана надо эмулировать несколько десятков запросов. 
- Размер теста. Нужно запустить «приложение», дождаться загрузки, эмулировать действия, для каждого экрана добавить вызов `onAppear` и т.д. При этом сценарий может проходить через десяток экранов. 

В итоге такие тесты писать достаточно сложно и может быть даже стоит оставить их на <doc:UI-testing>, но близость к реальному коду может упростить отладку в будущем, поэтому разберем какие инструменты могут упростить работу. 

После тестирования отдельных модулей у нас уже есть достаточно подготовленных инструментов: 
- Есть стабы на все ответы.
- Есть вспомогательные функции для вьюмоделей.
- Асинхронный код можно вызывать линейно в тесте.

@Comment {
    уже нужен пример хорошего теста
}

## Работа с запросами

Для загрузки главной страницы надо эмулировать много запросов к API. Управлять ответами мы уже умеем: и зависимость отделили и все `testMake` скорее всего уже написаны в <doc:3-2-network>. Осталось только собрать это все вместе в сложном сценарии. 

Что я делаю:
- Пишу единую функцию, которая нужна для старта приложения. Там могут быть пустые ответы, стандартные и т.п. Можно передать входящие параметры, с помощью которых будем управлять ответами. В функции должны быть описаны вообще все запросы, ее цель — стартануть приложение хоть как-то.  
- Затем вы захотите подменять отдельные ответы, чтобы привести приложение к нужному сценарию. Для этого я добавлю функцию `successOverride`: она удаляет старый респонс, а на его место ставит новый. Получается, что приложение может как запуститься, так и задать точечное поведение. 
- Скорее всего похожие функции лучше написать для каждого модуля/координатора. 

## Множественные координаторы

При тестировании главной страницы получается, что нам нужно обратиться ко всем вьюмоделям на пути теста. Например:
- Запускаем приложение с активным кредитом
- Жмем «выплатить». Появляется выбор способа платежа
- При оплате нужно пройти еще несколько экранов, иногда даже перейти в другое приложение
- После оплаты нужно вернуться в приложение и обработать universal link про успешную оплату
- Обновить баланс и список транзакций, чтобы увидеть платеж
- Обновить статус кнопки с кредитом

@Comment {
    Показать на видео или скриншотом
    Показать пример теста
}

Если мы прям так напишем в тесте, то получится слишком детально и тест *главного приложения* знает слишком много про *устройство внутри модуля*. Мы уже обсуждали, что для всего модуля часто управление может быть только через координатор, поэтому абстракция для каждого модуля в виде координатора хорошо подойдет для теста, который описывает связи между модулями.

@Comment {
    Пример теста и абстракций
}

### Зачем выносить функцию, если она используется только один раз?

При рефакторинге теста может появиться ощущение, что вы делаете слишком одноразовую работу: выносите функцию, которая вызывается в тесте только один раз. Я часто сталкиваюсь с этим ощущением в начале, но оно прям ложное:
- Хороший нейминг внутри теста — уже достаточное основание вынести функцию, а не писать комменатрий.
- Функции будут переиспользоваться, когда тестов станет больше, потому что тестируются не только успешные сценарии
- Хороший DSL упростит и понимание текущих тестов и написание новых
- Рефакторить тесты потом окажется проще

@Comment {
    перенести функции в модуль
}

## Размер теста

В итоге получается, что тесты на основной экран по своей структуре уже довольно близко к UI-тестам: 
- координаторы скрывают в себе целые сценарии, что похоже на Page-Object
- Сам тест очень верхнеуровневый, описывает общий сценарий для приложения.

Самое главное, что тест в итоге оказывается достаточно шаблонным, при этом тест выполняется за доли секунды, на UI-тесты нужно сильно больше времени. При этом вы можете запустить профилировщик относительно этого сценария, обсудим это в главе <doc:test-profiling>


## Таймауты и скорость выполнения

@Comment {
    рассказать про @TaskLocal
}
