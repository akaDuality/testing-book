@Tutorial(time: 30) {
    @Intro(title: "TDD-ката: боулинг") {
        «Разработка через тестирование» предлагает изменить привычку и сначала писать тест, а затем уже продакшен код для теста. Честно, у меня так получалось лишь несколько раз, но сам подход интересен, поэтому давайте его попробуем.
        
        Чтобы процесс шел проще придумали простые задания, цель которых — научиться писать много тестов, буквально на каждое действие в коде. Такие задания назвали TDD-катами.  
        
        1. <doc:2-1-TDD-Kata>
        
        @Image(source: TDD-cycle.PNG, alt: "TDD-цикл состоит из трех повторяющихся шагов: красных тестов, зеленых тестов и рефакторинга")
    }
    
    @Section(title: "Пишем первые тесты") {
        @ContentAndMedia {
            На катах легко отработать принцип «условия задачи меняются в процессе», поэтому не будем заранее читать все правила, пусть код меняется в процессе от новых требований. Тесты должны создать сеть проверок, которые сделают наш рефакторинг безопасным. 
            
            @Image(source: SafetyNet.png, alt: "Файл со свифт-кодом падает в сеть, на узлах сети зеленые галочки от пройденных тестов")
        }
        
        @Steps {
            @Step {
                В качестве задачки возьмем [расчет очков для боулинга](https://kata-log.rocks/bowling-game-kata).

                Нам надо начать с простейшего условия. Чаще всего подходят разные «нулевые» состояния. Так и запишем: в начале игры должно быть 0 очков. «Продакшен»-код начну писать в этом же файле. 
                
                > Tip: Основной объект тестирования я всегда называю `sut` – `system under test`, т.е. объект тестирования. Когда в тесте будут и другие объекты это упростит понимание «а кого мы тут вообще тестируем».
                
                @Code(name: "Tests.swift", file: TDD-0.swift)
            }
            
            @Step {
                Теперь можно подумать какое минимальное действие мы можем протестировать. Хорошо подходит учет броска со сбитием одной кегли.  
                Я только ввел `func roll`, а Xcode сначала предложил и название и тело теста. 
                
                @Code(name: "Tests.swift", file: TDD-1.swift) {
                    @Image(source: TestSuggestion.png, alt: "Предложенный код изображается прозрачным текстом")
                }
            }
            
            @Step {
                Немного причешем наш код: хочется отделить три шага, который есть почти в каждом тесте: **Arrange** – подготовка тестируемого объекта, **Act** — вызов нужного действия, **Assert** — проверка нового состояния системы. 
                
                Редко получается, чтобы в каждом шаге была только одна строчка, но отделать пустой строкой можно даже в сложных тестах. 
                
                @Code(name: "Tests.swift", file: TDD-1-2.swift)
            }
            
            @Step {
                Какой минимальный код нужно дописать, чтобы этот тест выполнился, но мы не протестировали слишком много? Забавно, но достаточно целиком прировнять переданное значение. Ну и заменить константу на `var`. 
                
                Такой подход контринтуитивен, но как принцип довольно интересен.
                
                > Tip: стоит запускать сразу все тесты нажимая `CMD+U`, так вы не пропустите упавший тест, если что-то сломаете новым изменением. 
                
                @Code(name: "Tests.swift", file: TDD-2.swift)
            }
            
            @Step {
                Теперь мы знаем, что поведение нашего кода неправильное, но наша задача для тренировки новых подходов научиться «прощупывать» поведение кода через тесты. Допишем тест, который заставит изменить код. Сделаем два броска подряд. 
                
                @Code(name: "Tests.swift", file: TDD-3.swift)
            }
            
            @Step {
                После нескольких тестов можно подумать что можно улучшить в их коде. Пока тесты очень простые, но во всех повторяется код по проверке счета. Мы можем вынести проверку в отдельную функцию.
 
                @Code(name: "Tests.swift", file: TDD-4.swift) {
                    @Image(source: WrongSourceLocation.png, alt: "Ошибка показывается внутри функции, а не в тесте") 
                }
            }
            
            @Step {
                У такой функции есть проблема: если тест покажет ошибку, то место ошибки окажется внутри функции, прямо на `#expect`! Нам надо, чтобы подсвечивались именно тесты. 
                
                Чтобы захватить параметры строки, в которой надо показывать ошибку в макросе expect есть дефолтный параметр `sourceLocation` — мы можем тоже собирать его и передавать в `#expect`, тогда ошибка будет подсвечиваться правильно. 
                
                > Tip: называйте все проверки с одинакового ключевого слова. В `XCTest` чаще использовали `assert`, в `Swift Testing` все перешли на `expect`. `Nimble` тоже использует `expect`. 
                
                @Code(name: "Tests.swift", file: TDD-5.swift) {
                    @Image(source: CorrectSourceLocation.png, alt: "При правильном указании `sourceLocation` ошибки показываются в тесте") 
                }
            }
        }
    }
    
    @Section(title: "Фреймы и спейры") {
        @ContentAndMedia {
            Усложним правила игры в боулинг: протестируем как игра делится на раунды (их называют фреймами, потому что рамка очищает дорожку от кеглей) и что будет если сбить все 10 кегль. 
            
            @Image(source: CraigBowling.png, alt: "Крейг Фидериге бросает шар для боулинга и сбивает кегли")
        }
        
        @Steps {
            @Step {
                Для начала введем ограничение: за один раунд можно бросить шар только два раза, при этом максимальное количество кеглей не может быть больше 10. 
                
                @Code(name: "Tests.swift", file: TDD-6.swift)
            }
            
            @Step {
                Со стороны кода будет сильно больше изменений: теперь нам нужно учитывать порядок бросков, а значит лучше их складывать в массив и считать уже по массиву. 
                
                Если мы пойдем рефакторить, то новый тест еще долго не позеленеет. Поэтому его можно отключить, отрефакторить код, убедиться, что все тесты зеленые, а потом добавить новый тест. 
                
                @Code(name: "Refactoring.swift", file: TDD-7.swift)
            }
            
            @Step {
                И вот тут у нас проблема с тем, что изменений ожидается много: надо отделить валидацию входных значений от расчет очков, при этом проверять четность броска и только для второго сравнивать сумму. 
                
                Давайте так и запишем! Тест позволяет нам не придумывать сложных абстракций и начать с простого кода, озеленить тест и уже потом думать как двигаться дальше. 
                
                @Code(name: "Refactoring.swift", file: TDD-7-2.swift)
            }
            
            @Step {
                На следующем шаге я могу усложнить этот же код и добавить проверку на четность бросков для всех раундов.
                
                При этом в коде четность текущего броска определяется по нечетности уже совершенных бросков... вот в такие моменты и нужны тесты: сначала код может выходить очень непонятный, но тесты подстрахуют нас и в дальнейшем рефакторинге. 
                
                @Comment {
                    // TODO: показать рефакторинг как важную часть процесса
                }
                
                > Note: мы пропустили валидацию минимального и максимального размера броска, но там ничего особенного нет. 
                
                @Code(name: "Refactoring.swift", file: TDD-8.swift)
            }
            
            @Step {
                Усложним задачку. Если за один раунд игрок сбивает все 10 кегль, то следующий бросок удваивается. 
                
                Чтобы повторить условие в тесте достаточно просто три раза вызвать бросок с разными цифрами, но читать такой тест сложно. 
                
                @Code(name: "Tests.swift", file: TDD-9.swift)
            }
            
            @Step {
                Сначала приберем структуру теста: первые два броска становятся первой arrange-честью теста, а в основном теле остается один бросок, который должен удвоиться.
                
                Во вторых мы можем более явно показать расчет очков прямо внутри `expectScore`
                
                @Code(name: "Tests.swift", file: TDD-10.swift)
            }
            
            @Step {
                Еще мы можем явно ввести функцию `spare`: так мы и себе от ошибок убережем и тест станет более читаемый. 
                
                @Code(name: "Tests.swift", file: TDD-11.swift)
            }
            
            @Step {
                Снова вернемся к рефакторингу: в каждом тесте есть создание объекта, можно убрать это дублирование. Для этого вынесем создание объекта игры на уровень `@Suite`. 
                
                > Warning: `sut` хоть и описан один раз в `@Suite`, но для каждого теста будет создаваться уникальный объект, чтобы тесты не зависели друг от друга. Такое поведение по-разному записывается в разных фреймворках, уточняйте как переиспользуется объекты и их зависимости в документации. 
                
                @Comment {
                    // TODO: ссылку на статью про жизненный цикл теста и разницу между XCTest и Swift Testing
                }
                
                @Code(name: "Tests.swift", file: TDD-12.swift)
            }
            
            @Step {
                Теперь структура arrange-act-assert снова читается в нашем тесте. 
                
                @Code(name: "TestsStructure.swift", file: TDD-13.swift)
            }
            
            @Step {
                Если вы чувствуете, что вам мешается обращение к `sut` в каждой строчке, то это тоже можно упростить. Делать так всегда не рекомендую, но чем сложнее тестируемая система тем больше вокруг нее появляется DSL. Главное, чтобы тесты было удобно читать и поддерживать!
                
                @Code(name: "NoSut.swift", file: TDD-14.swift)
            }
        }
    }
    
    @Section(title: "Страйки и максимум") {
        @ContentAndMedia {
            Давайте еще немного обсудим DSL на примере самых длинных тестов
            
            @Comment {
                // TODO: заменить крейга
            }
            
            @Image(source: CraigBowling.png, alt: "Крейг Фидериге бросает шар для боулинга и сбивает кегли")
        }
        
        @Steps {
            @Step {
                Когда мы начнем писать расчет страйков, то для этого стоит завести отдельную функцию. 
                
                Каждый раз вызывать `roll(10)` было бы несложно, но в этом и проявляется особенность DSL: мы привносим больше бизнес-языка в наши тесты, при этом продакшен-коду это даже не понадобится. Зато тесты потом поддерживать легко. 
                
                @Code(name: "Tests.swift", file: TDD-15.swift)
            }
            
            @Step {
               Закончим максимальным расчетом очков. В игре 10 раундов, в каждом из них можно бросить страйк. Так устроены правила, что для полного учета всех страйков вам дадут два дополнительных броска и вы сможете выбить 300 очков. 
               
               Можно записать это «в лоб», но тест становится слишком «техногенным». 
               
                @Code(name: "Tests.swift", file: TDD-16.swift)
            }
            
            @Step {
                Дополнительный DSL может упростить и этот тест. 
                
                
                @Code(name: "Tests.swift", file: TDD-17.swift)
            }
            
            @Step {
                В итоге на несложной задаче по расчету очков мы можем написать 15-20 тестов, потренировараться с разными аспектами тестов, почувствовать что в тестах нравятся, а что нет и выработать привычку писать тесты если не раньше кода, то прям вместе с ним.
                
                Полный пример тестов [в репозитории](https://github.com/akaDuality/BowlingKata/tree/master). В разных ветках тесты на разных фреймворках
                
                @Comment {
                    // TODO: переписать на Swift Testing и добавить скриншот переключения веток
                }
            }
        }
    }
}

@Comment {
    // TODO: рассказать, что начинать тест можно с ассерта
    // TODO: про нейминг given when then
}
