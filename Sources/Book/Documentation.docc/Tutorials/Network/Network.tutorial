@Tutorial(time: 30) {
    @Intro(title: "Как замокать сеть в приложении") {
        API-клиент — самая сложная и необходимая зависимость для клиент-серверного приложения. Он нужен для того чтобы показать превью в разных состояниях, он же нужен и для тестов. 
        
        Разберем пример стаба, который вы можете написать для своего приложения.
        
<!--        @Image(source: <#file#>, alt: "<#accessible description#>")-->
    }
    
    @Comment {
        // TODO: Удалить removeAfterExecution и перейти на счетчик. Все запросы по-умолчанию должны удаляться, чтобы избежать бесконечных лупов и сигналить произошло больше ожидаемых вызовов
    }
    
    @Section(title: "Сохраняем ответ от бэкенда") {
        @ContentAndMedia {
            Перед тем как начать стабать ответы от сети нам понадобятся сами стабы. Их легко накопить в процессе: как только вы договорились с командой про контракт или как только вы получили первый ответ от бэкенда сохраните его в коде, если ответ короткий или в виде JSON, если ответ очень большой. 
        }
        
        @Steps {
            @Step {
                Для всех Codable-структур я создаю метод `static func testMake() -> Self` в котором описываю вложенный объект. 
                
                > Tip: Такие функции легко собираются через LLM, достаточно передать контракт, попросить сгенерировать Codable-объект и функцию с примером его создания. 
                
                @Code(name: "TestMake", file: Profile+TestMake.swift)
            }
            
            @Step {
                Вложенные объекты можно собирать из других функций `testMake()`
                
                @Code(name: "TestMake", file: Profile+TestMake+Nested.swift)
            }
            
            @Step {
                Если нужна вариативность объекта, например, мне нужен профиль с разными емейлами, то можно вынести параметр, но поставить ему значение по-умолчанию.
                
                Для вложенных объектов это выглядит не очень красиво, но такое нужно не очень часто. 
                
                @Code(name: "TestMake", file: Profile+TestMake+Nested+Parameters.swift)
            }
            
            @Step {
                Для вложенных объектов это выглядит не очень красиво, но такое нужно не очень часто. 
                
                @Code(name: "TestMake", file: Profile+TestMake+Nested+Parameters+1.swift)
            }
            
            @Step {
                Вы можете создавать и конкретные профили, но главное начинать их все с одинакового слова, тогда просто набрав `.test` автоподстановка покажет возможные варианты, которые заготовил другой разработчик.
                
                > Tip: начинайте все стабы с одного префикса, чтобы вам помогала автоподставнока
                
                Может пугать возможная смена контракта в будущем, но мы именно эту проблему и решаем: если контракт изменится, то обновить его нужно будет только в месте изменения контракта, а все остальные тесты и превью будут использовать нашу функцию в которой все параметры по умолчанию уже имеют значение.
                
                @Code(name: "TestMake", file: Profile+TestMake+Nested+Parameters+Constants.swift)
            }
        }
    }
    
    
    @Section(title: "Интерфейс для стаба сети") {
        @ContentAndMedia {
            Сначала давайте разберемся что мы хотим от нашего стаба и как он будет использоваться. 
            
            @Image(source: <#file#>, alt: "<#accessible description#>")
        }
        
        @Steps {
            @Step {
                Нам нужен какой-то объект, в который можно добавить несколько ответов в формате запрос-ответ. При этом:
                - Можно подставлять `success`- и `fail`-ответы
                - Можно удалять стаб после его вызова
                - Можно стабать несколько ответов на один эндпойнт
                
                Для ответов мы будем подставлять функции `testMake()`, которые мы разобрали выше. 
                
                @Code(name: "Stub", file: APIProtocol2.swift)
            }
        
            @Step {
                Чтобы сделать такой стаб нам понадобится такой интерфейс
                
                @Code(name: "Stub", file: APIProtocol3.swift)
            }
        
            @Step {
                Все ответы будем сохранять в массив `jsonResponses`, при этом хранить данные в объекте `RequestDescriptor`: так мы сможем усложнять поведение нашего стаба, при этом все свойства будут храниться в одном месте. 
                
                @Code(name: "Stub", file: APIProtocol4.swift)
            }
        
            @Step {
                На каждый вызов нашего стаба мы просто сохраняем ответы в нужном формате. 
                
                @Code(name: "Stub", file: APIProtocol5.swift)
            }
        }
    }
    
    @Section(title: "Пишем стаб для сети") {
        @ContentAndMedia {
            Теперь реализуем стаб: посмотрим из чего он состоит и как можно упростить работу с ним. 
            
            @Image(source: <#file#>, alt: "<#accessible description#>")
        }
        
        @Steps {
            @Step {
                Допустим, у нас вот такой интерфейс для сетевых запросов. 
                
                @Code(name: "StubImplementation", file: StubError0-Interface.swift)
            }
            @Step {
                Найдем первый запрос из застабаных. Ожидаем, что порядок вызовов примерно совпадает с порядком стабов
                
                @Code(name: "StubImplementation", file: StubError0.swift)
            }
            
            @Step {
                Вернем результат стаба. Функция `try get()` возвращает результат если застабан `.success()` или выбросит ошибку, если застабан `.failure`
                
                @Code(name: "StubImplementation", file: StubError1.swift)
            }
            
            @Step {
                Если указали флаг, что запрос надо удалять после вызова, то удалим его. 
                
                @Comment {
                    Если сделать наоборот, то ошибки проще находить будет на полинге
                }
                
                @Code(name: "StubImplementation", file: StubError2.swift)
            }
            
            @Step {
                Возможен сценарий, когда не застабали запрос. С помощью библиотеки `IssueReporting` мы можем показать фиолетовое предупреждение и подсказать какой запрос надо застабать. 
                
                @Code(name: "StubImplementation", file: StubError3.swift)
                
                @Comment {
                    // TODO: Показать как вывести сообщение о кривом стабе прямо в тест
                }
            }
            
            @Comment {
                // TODO: Показать пример варнинга
            }
            
            @Step {
                Если запрос вызвали, то сохраним факт вызова в массиве. Позже мы сможем написать снепшоты и смотреть все вызовы
                
                @Code(name: "StubImplementation", file: StubError4.swift)
            }
        }
    }
    
    @Section(title: "Мокаем превью") {
        
        @ContentAndMedia {
            Можно даже тесты не писать, а прямо так использовать наш стаб для того. чтобы наполнить вьюшку нужными данными. 
            
            @Image(source: <#file#>, alt: "<#accessible description#>")
        }
        
        @Steps {
            
            @Comment {
                // TODO: Показать как мы будем узнавать о пропущенных моках
            }
            
            @Step {
                Добавим сеть к превьюшке. 
                
                @Code(name: "Preview", file: Preview0.swift)
            }
            
            @Step {
                Теперь сеть можно застабать прямо внутри превью: создаем объект и указываем какой ответ надо подменить
                
                @Code(name: "Preview", file: Preview1.swift)
            }
            
            @Step {
                Если использовать фреймворк Dependency, то можно не передавать объект через конструктор, а заменить его в контексте. Выглядит странно...
                
                @Code(name: "Preview", file: Preview2.swift)
            }
            
            @Step {
                ... но это позволяет перенести стабы прямо в описание превью! Наглядно, что зависимости отделены от самого объекта, в тестах это будет работать точно так же. 
                
                @Code(name: "Preview", file: Preview3.swift)
            }
            
            @Step {
                Увы, для Prefire придется все свернуть обратно в один объект.
                
                @Code(name: "Preview", file: Preview4.swift)
            }
        }
    }
    
    @Section(title: "Мокаем тесты") {
        @ContentAndMedia {
            
            @Image(source: <#file#>, alt: "<#accessible description#>")
        }
        @Steps {
            @Step {
                С таким стабом мы можем описать наши ответы, при этом если что-то забудем тест нам подскажет. 
                
                > Note: сам тест очень простой, вся сложность стабов находится за пределами теста. Если эти запросы повторяются для нескольких тестов, то можно упростить их через дополнительный DSL.
                
                @Code(name: "Result", file: Result1.swift)
            }
            
            @Comment {
                // TODO: Раскрыть подробный сценарий написания теста через варнинг
            }
        }
    }
    
    @Section(title: "Снепшот запросов") {
        @ContentAndMedia {
            Мы написали мощный мок, который можно применять к превью и тестам, чтобы контролировать поведение нашего кода, но можно пойти еще дальше и бесплатно получить проверку всех вызываемых запросов
            
            @Image(source: <#file#>, alt: "<#accessible description#>")
        }
        @Steps {
            @Step {
                Для этого нам понадобится фреймворк `InlineSnapshotTesting`. Допишем вот такенную функцию, которая просто перенаправляет вызов к библиотеке и подменят стратегию тестирования на `.network`.
                
                @Code(name: "Snapshot", file: Snapshot1.swift)
            }
            
            @Step {
                Реализуем эту стратегию. Я тестирую целый сценарий, поэтому мне понадобится просто короткий перечень путей. 
                
                @Code(name: "Snapshot", file: Snapshot2.swift)
            }
            
            @Step {
                Мы остановились вот на таком тесте. 
                
                @Code(name: "Snapshot-Test", file: Result1.swift)
            }

            @Step {
                Теперь достаточно вызвать нашу функцию... 
                
                @Code(name: "Snapshot-Test", file: Snapshot3.swift)
                
            }
            
            @Step {
                ...и история запросов сгенерируется и допишется в файл самостоятельно!
                
                @Code(name: "Snapshot-Test", file: Snapshot4.swift)
                
            }
        }
    }
}
