# Наглядные падения тестов

Самое сложное в поддержке тестов это быстро понимать почему тест упал и что сделать, чтобы исправить тест или понять ошибку в коде. Есть несколько техник и инструментов, которые помогают в этом

## Fail first

Все подходы к тестированию рекомендуют сначала написать падающий тест: 
- так вы убедитесь, что ошибка вообще была и вы ее исправили
- вы увидите как выводится ошибка и насколько она помогает понять проблему.

Как правило надо придумать лишь несколько стратегий по работе с ошибками на уровне архитектуры зависимостей, чтобы легко находить проблемы в  

## throws в коде

Самый простой тип: если у вас есть throws функция и она вернет ошибку, то тест упадет. Главное не погасить ошибку в коде или на уровне теста, тогда сам тест тоже завершится с исключением и тест упадет.

```swift
@Test func canMakeRequest() async throws {
    let profile = try await apiClient.send(profileRequest())
    #expect(profile.name == "Homer Simpson")
}
```

## Кастомные ассерты и место вызова

Часто для тесткейса нужно проверять одни и те же проверки. Например, в конце многих сценариев регистрации я проверяю, что пользователь авторизован. Каждый раз писать полную проверку на наличие токенов, номера телефона и userId странно, лучше вынести функцию проверки и переиспользовать

```swift
extension Storage {
    func expectAuthorized() {
        try #require(accessToken)
        try #require(refreshToken)
        try #require(phoneNumber)
        try #require(userId)
    }
}
```

Если проверка не очень очевидная, то можно добавить и дополнительное сообщение, оно покажется в случае ошибки. 
```swift
try #require(userId, sourceLocation: sourceLocation, "can't read `userId` from `accessToken`")
```

@Comment {
     показать ошибку на скриншоте
}

Для таких функций нужно еще передавать и `sourceLocation` — место в тесте, где эта функция вызывается, чтобы ошибка показывалась в тесте, а не где-то в середине функции по проверке. Для этого добавим параметр со значением по-умолчанию и передадим его в каждый `#require` и `#expect` 

```swift
extension Storage {
    func expectAuthorized(
        sourceLocation: SourceLocation = #_sourceLocation
    ) {
        try #require(accessToken, sourceLocation: sourceLocation)
        try #require(refreshToken, sourceLocation: sourceLocation)
        try #require(phoneNumber, sourceLocation: sourceLocation)
        try #require(userId, sourceLocation: sourceLocation)
    }
}
```

@Comment {
    показать до и после 
}

Этот подход можно посмотреть в туториале <doc:2-1-TDD-Kata>

## IssueReporting

Иногда нам нужно прокинуть источник ошибок очень далеко от теста: например, если мы хотим показать, что какой-то сетевой вызов забыли застабать. Для этого мы точно так же можем передать sourceLocation в конструктор зависимости, а потом подставить его в `IssueReporting`. Библиотека IssueReporting позволяет показывать фиолетовый варнинг при работе Preview и ронять тест, когда код запустили в тестовом окружении.  

Смотри туториал <doc:tutorials/Network>

## Ошибки внутри экранов и ToastQueue

- ошибки внутри экрана
- лог шагов, чтобы быстро найти нужный
- стаб аналитик

## Снепшот-тесты

