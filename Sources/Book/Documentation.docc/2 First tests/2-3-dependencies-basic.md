# Зависимости

Больше всего тестирaванию кода мешает зависимости — объекты, чье поведение влияет на результат выполнения вашего кода. Зависимости стоит отделять и контролировать и вообще всячески любить, ведь через них придется написать все тесты. 

### Тестируемость кода на уровне функции

Важная задачка архитектуры — сразу сделать «тестируемо». Тесты можно написать или забить, но вот писать код *потенциально-тестируемо* очень важно. Давай разберемся что это такое.

У любого тестируемого кода есть вход и выход: так можно было передать разные параметры и проверить результат. Это могут быть разные вызовы VS проверка состояния объекта, но суть та же самая.

Все просто, когда есть простое выходное значение. Например, функция может быть сложной внутри, но мы можем подавать разные значения и результат будет стабильным на выходе:

```swift
func isExpired(now: Date, deadline: Date) -> Bool {
    return now < deadline
}
```

Протестировать невероятно легко:
```swift
@Test func `is not expired before deadline`() {
    let isExpired = isExpired(now: .now, deadline: .now.addingTimeInterval(60))
    #expect(isExpired == false)
}

@Test func `is expired after deadline`() {
    let isExpired = isExpired(now: .now, deadline: .now.addingTimeInterval(-60))
    #expect(isExpired == true)
}

@Test func `is expired right on deadline`() {
    let isExpired = isExpired(now: .now, deadline: .now)
    #expect(isExpired == true)
}
```

Но тестируемость этой функции легко сломать:
```swift
func isExpired(deadline: Date) -> Bool {
    return Date.now < deadline
}
```

Что изменилось? Внутри функции появилось значение, которое разное при каждом вызове, т.е. наш код зависит от значения стороннего объекта Date. Такие объекты будем называть зависимостями. 

Передавать параметр текущей даты каждый раз утомительно и нужно только для тестов, поэтому можно передать значение по-умолчанию: 

```swift
func isExpired(now: Date = .now, deadline: Date) -> Bool {
    return now < deadline
}

// Production code
isExpired(deadline: Date("24/08/2025"))
```

### Виды зависимостей
Разных зависимостей достаточно много:
- Настройки и состояние телефона: Date, Calendar, TimeZone, уровень батарейки, значения настроек доступности, локация и т.п. Библиотека Dependencies уже содержит пачку стандартных контролируемых зависимостей. 
- «Фичевые»: ответы API, аналитика, верстка, навигация между экранами. 
- Внешние: капча, KYC-валидация людей через камеру, сторисы, Apple Pay, оплата через сторонние приложения, WebView для 3ds и т.п.

Хорошая новость — у вас в проекте лишь пара десяток таких зависимостей и каждой нужно научится управлять: как проверять вызовы к зависимости так и подменять ее поведение. Самое главное — нужно научиться управлять ответами от API, это обсудим в главе <doc:3-2-network>.

### Зависимости на уровне класса и фреймворк Dependency

Сложнее становится работа с зависимостями на уровне класса. Чаще всего начинают создавать протокол на объект (типо DateProvider), писать мок на этот протокол, подменять его реализацию через конструктор… в общем очень избыточно и сложно рефакторить.

Point-Free предлагают такой подход: подменять можно на уровне функций. 
- Нам нужно получать текущую дату, пусть это будет функция () -> Date
- У нее должно быть значение по-умолчанию, это может быть () -> Date = .now
- Функцию можно передать в конструкторе и вызывать когда нужно

```swift
class ProductExpiration {
    
    var now: () -> Date
    
    init(now: () -> Date = .now) {
        self.now = now
    }

    func isExpired(deadline: Date) -> Bool {
        return now() < deadline
    }
}
```

В тестах текущую дату можно подменить так:
```swift
@Test func `is expired after deadline`() {
    let sut = ExpirationService(now: { Date("24/08/2025") }) 
    let isExpired = sut.isExpired(deadline: Date("23/08/2025"))
    #expect(isExpired == true)
}
```

Набор стандарных зависимостей Point-Free собрали в библиотеке [Dependencies](https://github.com/pointfreeco/swift-dependencies). Со стороны использования это выглядит так:

```swift
class ProductExpiration {
    @Dependency(\.date.now) var now 

    func isExpired(deadline: Date) -> Bool {
        return now() < deadline
    }
}
```

Ну это отвал башки ваще: 
- тип можно поменять сразу на все приложение,
- в конструкторе ничего не нужно передавать,
- клево задается для превьюшек:

```swift 
@available(iOS 18.0, *)
#Preview(trait: .dependencies { $0.date.now = Date("1/01/2025") }) {
    FeatureView(model: FeatureModel()) // Где-то там внутри создается ProductExpiration
}
```
@Comment {
    это задепрекейтили
}

Клево работает через SwiftTesting:

```swift
struct FeatureTests {
    @Test(.dependencies { deps in 
        deps.date.now = Date("1/01/2025")
    })
    func `is expired after deadline`() {
        let sut = ExpirationService() 
        let isExpired = sut.isExpired(deadline: Date("23/08/2025"))
        #expect(isExpired == true)
    }
}
```
### Сделать прототип = исследовать зависимости 

Роль зависимостей настолько велика, что по сути создания прототипа приложения нужно для исследования работы зависимостей. Представьте, что вам нужно сделать приложение которое завязано на геолокацию. Как начать с тестов? Да никак: надо почитать документацию, сделать демо-проект и начать разрабатывать в нем, понять от чего зависит поведение зависимости, накопить какие-то данные для примера. И вот в конце такого исследования можно напрограммировать качественную зависимость и разными требованиями: 
- При разрешении пермишена будет возвращать заданную локацию.
- Если пермишен уже давали в этой сессии, то вернет локацию сразу.
- Может прочитать изменений локации из файла 
- По-разному покажет поведение на разных версиях iOS
- Обработать запрет пермишена

И когда вы уже понимаете ограничения всей системы, то можно начать встраивать сценарий в ваше приложение и писать тесты. 

### Зависимости VS Моки

Во многих компаниях устоялся такой подход к тестированию, что отделять нужно каждый класс через интерфейс и поверх интерфейса программировать мок прямо в тесте. Мне такой подход не нравится, потому что порождает огромное количество бесполезных интерфейсов, каждый тест становится слишком независимым, а при программировании мока легко ошибиться. 

Другая проблема разработки через моки — ломается уровень детализации в тесте, потому что моки программируются не в отдельном DSL, а прямо в тесте.

@Comment {
    Вынести в отдельную главу. И в оглавлении курса написать, что моков не будет
}
