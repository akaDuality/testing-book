# Примеры тестов в пирамиде тестирования

Пирамида тестирования необычная в мобиле. Кратко посмотрим на примеры тестов, которые будем разбирать дальше в курсе.  

## Overview

Тесты нужны разные, тестов будет много. Посмотрим из чего состоит мобильное приложение и как можно тестировать эти части. 

От простого к экзотичному: тестирование верстки экранов, вьюмоделей, сценариев приложения и общей архитектуры. 

### Верстка экранов

Большую часть времени мобильный разработчик тратит на верстку. В ней же основная сложность: 
- поддержка разных размеров экранов, 
- светлая и темная тема, 
- разные размеры шрифта, 
- направления текста (в арабских странах пишут справа-налево), 
- вестка для телефона/планшета, 
- текстовое описание для скринридера.   

Часть настроек можно смотреть с помощью макроса `#Preview`, а скриншот-тесты позволяют сохранить картинки с итоговой версткой в репозиторий.

При этом в приложении много экранов, они бывают в разных состояниях, например, загрузка данных, отображение данных и ошибка. Для полного покрытия нужно так научиться управлять зависимостями, чтобы приводить экран в любое конечное состояние.  

Через скриншот-тесты легко тестировать и компоненты дизайн-системы. При этом скриншоты целых экраном покажут как дизайн-система повлияла на них, поэтому изменив одну кнопку можно будет увидеть все изменения в приложении.  

Более того, с помощью библиотек можно генерировать скриншот-тесты прямо из Preview. Пример с использованием библиотеки Prefire и Dependencies:   

```swift
import Prefire

#Preview("RemittanceScreen_eligible_initial") {
    withDependencies({ deps in
        deps.api = APIStub.builder()
            .success(
            RemittanceAPI.stub_rate(amount: 0), .testMake(sending: 0, available_loan: .testMake())
            )
            .build()
    }, operation: {
        RemittanceScreen(viewModel: makeVMForPreview())
    })
    .snapshot(delay: 0.1)
}
```

@Image(source: Loan-scenario.png)

При этом через скриншот-тест мы захватили и часть презентационной логики. На примере выше , я позволяю экрану стартануть и стабаю данные из сети, а затем смотрю как экран отобразил эти данные. Так захватывается разная логика по смене состояний, мапингу данных и т.п. При этом скорость прохождения теста не особо меняется, а вот мне меньше тестов писать. 

> Tip: Тестируя через скриншоты вы дополнительно захватите и часть экранной логики. Это хорошо, потому что так нужно будет написать меньше тестов. 

### Тестирование логики внутри экрана

Дополнительно к скриншот-тестами можно дописать и тесты на вьюмодель, чтобы проверить то, что не видно визуально:
- Обработка ошибок и восстановление после них.
- Вызовы невизуальных зависимостей. Например, что сохранилось на диск.
- Команды Undo и Redo. 

> Tip: для простых экранов хватит скриншот-тестов, а сложных экранов не так уж много. 

Например, я хочу для экрана международного перевода ввести сумму, дождаться расчета курса, выбрать кредит и применить его... а затем еще сменить размер кредита и подтвердить перевод. Звучит очень сложно, но в тесте записывается очень коротко: 

```swift
@Test(.dependencies { deps in
    deps.api = APIStub.builder()
        .success(RemittanceAPI.stub_quote(), .testMake(rnpl: .testMake()))
        .success(RemittanceAPI.stub_submitRemittance(), .testMake())
        .build()
})
func whenEdit_shouldUseCorrectValues() async throws {
    try await sut.inputFromAndWaitQuote(200)
    sut.editLoan()
    try await sut.selectLoanAmountAndWait(10)
    sut.applyLoan()

    sut.editLoan()
    try await sut.selectLoanAmountAndWait(40)
    sut.applyLoan()

    try await sut.confirm()
}
```
Чтобы команды в тесте можно было вызывать друг за другом я использую вспомогательные функции, которые можно вызывать через await:

```swift
func waitQuote() async throws {
    try await #require(quoteTask).value
}
```

@Comment {
    тут пригодится fireAndForget
}

### Заглянуть внутрь кода

Тесты стоит описывать через пользовательские сценарии и смотреть что они в целом выполняются. Но иногда все же хочется более детально посмотреть что происходит в зависимостями в тесте: какие запросы вызываются, какие события аналитики отправили и т.д. 

Для таких проверок очень помогают снепшот-тесты: слепок данных, которые тоже сохранится в репозитории и будет сравниваться с последующими прогонами тестов. В примере ниже я проверю как вызывались сетевые запросы в сценарии ввода суммы для кредита из теста выше. 

```swift
@Test(.dependencies { deps in
    // ...
})
func whenEdit_shouldUseCorrectValues() async throws {
    // ...

    assertInlineSnapshot(of: sut.loadingHistory, as: .dump) {
    """
    ▿ 3 elements
        ▿ RateLoadingRequest
            - amount: 200.0
            - amountSource: .from
            - loanAmount: "null"
        ▿ RateLoadingRequest
            - amount: 200.0
            - amountSource: .loan
            - loanAmount: "10.0"
        ▿ RateLoadingRequest
            - amount: 200.0
            - amountSource: .loan
            - loanAmount: "40.0"
    """
}
```

В тесте видно, редактирование какого поля на экране вызывало запрос и с какими суммами он вызывался. При этом вам даже не нужно писать строку с результатами, потому что она сгенерируется автоматически и подставится прямо в код, вам нужно лишь убедиться, что результаты правильные.    

Имея систему из сценариев можно в целом добавлять разные проверки на качество работы кода: 
- Как быстро рендерятся экраны
- Есть ли утечки памяти
- Как много читали данных с диска,
- Как работает многопоточность под нагрузкой и т.п.


### Тестирование сценариев из нескольких экранов внутри модуля

Часто сценарии выходят за рамки одного экрана:
- Выбрал товар в каталоге продуктов, открыл карточку, настроил размер/цвет и добавил в корзину
- Выбрал в какую страну делать перевод, в какой банк, ввел реквизиты человека, проверил, что данные реальны, ввел сумму и отправил перевод. 

Последний пример в виде теста: можно застабать все запросы и пройтись по сценарию через вьюмодели каждого экрана. При этом тесты будет очень быстрый: экраны не рендерятся, а вот передача данных проверяется. 

@Image(source: Remittance-scenario.png)

```swift
@Test(.dependencies { deps in
    deps.api = APIStub.builder()
        // Saved Beneficiaries
        .success(RemittanceAPI.savedBeneficiaries(), [.testMake()])
        // New beneficiary
        .success(RemittanceAPI.countries(), .testMake())
        .success(RemittanceAPI.providers(toCountry: .pak), [.testMake()])
        .success(RemittanceAPI.stub_beneficiaryFields_bankOfPakistan(), .testMakeNewBank())
        .success(RemittanceAPI.stub_beneficiaryRequest(), .valid(.testMake()))
        // New loan
        .success(RemittanceAPI.stub_quote(), .testMake())
        .success(RemittanceAPI.stub_submitRemittance(), .testMake())
        .build()
})
func newBeneficiary_newBank_shouldRouteToQuoteScreen() async throws {
    sut.start()

    try viewModel(route: \.beneficiarySelection).createNewUser()
    try await viewModel(route: \.countries).selectPakistan()
    try await viewModel(route: \.providers).selectNew()
    try await viewModel(route: \.userDetails).process(addBankDetails: true)
    try await viewModel(route: \.remittance).process(amount: 200, source: .from)

    let transactionVM = try #require(sut.showTransactionPopover)
    try await transactionVM.process()
}
```

В таких тестах функция целого экрана сводится до простых вспомогательных функций, например:

```swift
extension ProvidersViewModel {
    func selectNew() async throws {
        try await load()
        select(provider: nil)
    }
}
```

### Связи между модулями и бизнесовые сценарии

К этому моменту мы проверили верстку, логику внутри экрана, переходы между экранами и как данные передаются между ними. При этом тестировали мы внутри отдельного модуля. Остается проверить как визуально срабатывает навигация и как модули связаны между собой. Проще всего это сделать через UI-тесты. Чаще всего UI-тесты еще и запускают поверх реального бэкенда, чтобы проверить работу приложения end-to-end.

UI-тесты работают с приложением обращаяюсь к текстовому описанию элементов на экране. Чтобы было проще писать такие тесты создают специальные Page-Object, которые скрывают необычный API поиска по тексту и описывают тесты так, чтобы их было легко читать. От этого текст выходит довольно верхнеуровневый:

```swift
@MainActor
func test_connectAccount_addMoney_shouldTransferMoney() {
    launch(as: .accountWithoutConnectedBank)

    account.addMoney()

    XCTContext.runActivity(named: "Connect account") { _ in
        addMoney.connectNewAccount()
        addMoney.connectBank()
        addMoney.allowPermissions()

        openBankingWebView.connectAccount()
    }

    XCTContext.runActivity(named: "Payment") { _ in
        addMoney.input(amount: "100", pressPay: true)

        openBankingWebView.confirmPayment()
        addMoney.expectSuccessScreenAndClose()
    }
}
```

### Архитектурные тесты, которые единым правилом проверяют весь код

Если пойти чуть шире и представить тесты как «набор автоматических проверок поверх кода», то можно проверять не только функциональные свойства «что мы делаем», но и свойства самого кода. 

Такое позволяет сделать библиотека `Harmonize`. Например, тест, который проверяет, что все вьюмодели мы договорились делать через @Obsevable-макрос. 

```swift
@Test
func allViewModels_shouldBeObservable() {
    let viewModels = Harmonize.productionCode()
        .classes().withSuffix("ViewModel")

    viewModels.assertTrue { viewModel in
        viewModel.attributes.contains { attribute in
            attribute.name == "Observable"
        }
    }
}
```

## Требования для тестов

Просуммируем все требования для тестов из примеров выше.

### Библиотеки и подходы
В своих проектах я использую несколько разных библиотек для тестирования
- Swift Testing используем для тестов, это фреймворк от Apple
- [Swift Dependencies](https://github.com/pointfreeco/swift-dependencies) упрощает контроль зависимостей
- CasePathable поможет описать маршруты навигации
- Harmonize позволяет написать архитектурные тесты
- Для асинхронности будем использовать Structured Concurrency: использовать async/await и Task. Это позволит писать тесты более синхронно. 

@Comment {
    добавить ссылки
}

### Контроль зависимостей

Логика приложения всегда зависит от динамичных параметров: сеть, время, настройки телефона, хранение файлов, состояние других частей приложения (например, баланс счета при переводе денег). Код логики нужно писать так, чтобы вы могли задать любой входящий параметр и посмотреть на итоговый результат

В примерах выше я использую библиотеку [Swift Dependencies](https://github.com/pointfreeco/swift-dependencies), а как задизайнить зависимости для сети рассказываю в туториале <doc:tutorials/Network>

### Мониторинг и воспроизводимость

Любой баг с прода надо уметь повторять. Для этого вам нужно знать что человек сделал в приложении (часто — через аналитику) и какой ответ зависимостей был (из логов). 

### Многомодульность
Тесты должны запускаться и прогоняться как можно быстрее, потому что тестов будет много. Чаще всего стоит разбить приложение минимум на несколько крупных модулей, которые вы будете тестировать по-отдельности. 

Например, в приложении для доставки еды: определение геолокации/адреса, выбор продуктов и настройка, добавление в корзину, регистрация, оплата, трекинг заказа, оценка после заказа. 

Минимальный банк: регистрация/открытие счета, пополнение счета, перевод денег, список транзакций. 

Работая с каждым модулем по-отдельности:
- Уменьшается размер задачи и количество кода
- Ускоряется сборка и прогон тестов
- Короче контекст для LLM. 


### Тестируемая архитектуры

Чтобы писать все эти виды тестов понадобится разный набор инструментов и архитектурных решений. Основная сложность будет во внедрении и обучении разработчиков, стоит это поручить самым сильным разработчикам. В книге будет много примеров к какому состоянию вам можно прийти, а ваш индивидуальный путь из текущего состояния вам придется проложить самим.    

### Демо-приложения

Контролируемые зависимости и многомoдульность позволяют делать разные версии приложений удобных для разработки. Например, можно убрать из билда все сложные зависимости про капчу, чат, Firebase и т.п., потому что разработчикам во время написания кода они не нужны, так ускорится билд. 

Если с каким-то модулем приходится работать отдельно, то для него можно сделать демо-приложение. Так в Додо Пицце мы отделяли модуль оплаты и AR-пиццы. Для таких демо-приложений можно даже написать отдельные UI-тесты. Так мы тестировали десятки способов оплаты не создавая заказ. 


