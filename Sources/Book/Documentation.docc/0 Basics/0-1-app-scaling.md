# Рост приложения

Что меняется с ростом приложения и как эти проблемы решает многомодульность и тесты

С ростом приложения сильно увеличивается количество кода и количество людей, которые над ним работали в какое-то время. Если ничего не делать, то в какой-то момент наступит состояние, когда количество условий о которых надо подумать при изменении кода уже не помещается в голову, а про некоторые и некого спросить, потому что разработчик ушел из проекта пять лет назад (ну или просто забыл что было так давно). Разделение на модули уменьшит контекст, а тесты помогут не забывать про старые требования.

## Многомодульность

### Большая команда → Разделение ответственности

Представьте, что в вашем проекте 30 *команд*. Это значит, что каждая меняет код, постоянно сталкиваются в одинаковых местах, возникают конфликты, разработчики ломают изменения друг друга и задачи постоянно уходят на доработки. 

Решать эту проблему стоит не с кода, а организации работы, чтобы каждая команда отвечала за какой-то свой домен и никто без её ведома код больше не менял. Чаще всего делят по функционалу:
- Приложение для заказа пиццы? Делите команды на выбор адреса и способа заказа, каталог, конструкторы продуктов, корзина, свойства заказа, платежами, экраны доставки, оценки, мессенджера.
- Электронный кошелек? Делим на регистрацию, главный экран, пополнение денег, переводы, кредиты, и прочие услуги. 

Конечно, чаще всего команд сильно меньше, чем таких доменов. Тогда команда отвечает за несколько разделов приложения. 

Работе может делиться и не только по фичам. Например, если в приложении для заказа еды надо поменять описание товара, то эти изменения потянут за собой изменений и в каталоге и в корзине, что может стать слишком большими изменениями для одной компанды. Поэтому некоторые проектах команды могут объединяться и работать сообща, в другое время работать независимо. 

Если кому-то надо аккуратно залезть в соседний домен, то можно проконсультироваться у соседней команды и позже принести pull request не ревью. Всегда будут проблемы и от деления на домены, но эти проблемы можно хоть как-то планировать и решать.  

### Разделение ответственности → многомодульность

Изменение структуры команды обычно влияет и на код. Если вы работаете лишь над одним участком кода, то он должен иметь какую-то свою форму и границы. Границы могут быть разными:
- Весь код команды собран в одной папке. Самый ненадежный способ без особых плюсов, но может быть ступенькой для следующих шагов. 
- Код команды лежит в модуле: статичной библиотеке или динамичном фреймворке. Уже удобно, потому что можно не собирать весь проект и работать над модулем как над продуктом. Границы модуля видны компилятору. 
- Код модуля лежит еще и в отдельном репозитории. Удобно, если код совсем не зависит от проекта. Например, модуль платежной системы может быть в закрытом репозитории, а итоговый код подключаться бинарным модулем: так сложно будет узнать детали реализации, что повышает безопасность и подходит для прохождения сертификации по хранения и обработке данных карточек — PCI-DSS.  

## Автотестирование 

### Время идет → Разработчики меняются → Знания теряются

Если проект развивается десять лет, то над ним поработают десятки или даже сотни разработчиков. 

С одной стороны разработчики меняются по составу: кто-то проработает несколько лет и уйдет. Кто-то ушел недавно, а кто-то давно. В общем, вряд ли у вас рядом окажутся все нужные люди, которые работали над кодом, который вы сейчас открыли.    

С другой стороны другие разработчики будут работать многие годы, но и они нормально не вспомнит что писали несколько лет назад и какие там требования к задаче всплыли в последний момент. 

Меняется и качество разработчиков. Может быть несколько лет назад был разработчик, который знает как к интерфейсам добавлять текстовое описание для скринридера. А потом придет разработчик, который вообще не поймет зачем этот код, удалит его, увидит, что никакого видимого влияния не произошло и так и оставит.   

> Note: знание разработчиков непостоянны, на них нельзя опираться 

### Знания теряются → Проект устаревает → Теряется смелость

Разработчиков постоянно торопят. Если приходится менять код, которые написан давно, то хочется побыстрее понять что там было, изменить минимум, чтобы не сломать то, что работало. Но это же ужасно: вместо полноценной адаптации кода под новые требования и переосмысления старых требований код превращается в набор заплаток. С каждой следующей итерацией становится все хуже.   

Даже если тестировщики писали тесткейсы, то они могут потеряться, устареть и непонятно как хорошо покрывают все требования. Да и проверять все равно придется руками.   

В итоге главная разница между старым проектом и новым:
- в новом ты можешь начать писать где угодно, мало чего нужно держать в голове, двигаться быстро. 
- в старом оказывается так, что написанный код может содержать даже больше знаний, чем есть в голове у разработчика. 

И если в итоге оказывается, что код никто не может поменять, потому что страшно сломать — увы, проект состарился и со временем этот процесс будет только ухудшаться, потому что новые разработчики так же будут стараться изменить как можно меньше кода и весь проект превратится в лоскуты изменений. 

### Вернуть смелость

В долгосроке важным оказывается то, насколько смело разработчик может менять систему. Если я могу изменить пару строчек, запустить тесты и через несколько секунд увидеть что я сломал, то мне легко экспериментировать, потому что не надо пытаться подумать над всем сразу. Нужно меньше держать в голов, от этого смелее и быстрее работается.   

> Tip: тесты сделают ваших разработчиков смелее
