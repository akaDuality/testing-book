# Снепшот-тестирование

Часто от тестирования хочется не столько проверить конечный результат, сколько заглянуть «под капот» кода и узнать а что там в итоге навызывалось. Например, вызов одной функции может вызвать несколько сетевых запросов или залогировать парочку событий аналитики с кучей данных. Данных может быть так много, что писать их внутри теста будет неудобно, а помочь сможет снепшот-тестирование. При этом нам может быть даже не очень интересно что именно там пишется: достаточно проверки что выходные данные не поменялись.

## Принцип работы

Идея простая: я не хочу описывать какой результат хочу, но я могу прогнать тест и пусть код сам запомнит что получилось. При последующих прогонах будем сравнивать результат с тем, что хранится в репозитории. Если вы поменяли код и прошлый снепшот вас не устраивает, то просто удалите его и сгенерируйте новый. 

Фактически для iOS работает как магия: вы пишите тест, вызываете ассерт снепшота и после прогона теста ваш код дописывается результатом вызова! При первом прогоне тест останется красным, потому что ему не с чем было сравнить результат, но если запустить еще раз, то результат работы кода сравнится с ожидаемым результатом. Если текст расходится, то вы увидите построчный diff между двумя блоками текста, так что разницу найти достаточно легко. 

@Comment {
    Показать на видео
}

Эталонный текст может храниться не в коде, а в отдельном файле рядом с тестами. Так чуть сложнее редактировать, но проще удалять все снепшоты за раз, например, если вы переписали сам формат снепшота данных.  

> Tip: в интернете такой подход можно найти под названием golden-master-тестирование, т.е. «сравнение с образцом» 

## Библиотека

Самая популярная библиотека на iOS от [Swift Snapshot Testing от Point-Free](https://github.com/pointfreeco/swift-snapshot-testing). В библиотеке есть встроенные стратегии для нескольких типов данных, можно снепшотить в файл или в код, легко расширяется собственными стратегиями тестирования и есть большое количество [других библиотек](https://github.com/pointfreeco/swift-snapshot-testing#plug-ins), которые опираются на нее, например, мы уже смотрели на <doc:3-3-preview-prefire>.  

## Дефолтные стратегии

Любой Codable-объект
```swift
assertSnapshot(of: user, as: .dump)
// ▿ User
//   - bio: "Blobbed around the world."
//   - id: 1
//   - name: "Blobby"

assertSnapshot(of: user, as: .json)
// {
//   "bio" : "Blobbed around the world.",
//   "id" : 1,
//   "name" : "Blobby"
// }
```

## Spy-объекты

Часто в тестировании хочется проверить не один конечный результат, а посмотреть цепочку вызовов у зависимости: 
- Какие сетевые запросы мы делали
- Какие аналитические данные отправляли
- Какие функции вызывали у зависимости. 
- Какие состояния были у вьюмодели. 
 
Например, я хочу посмотреть как запрашивался курс валюты на экране для перевода денег:
- Наследуюсь от вьюмодели
- Добавляю переменную которая будет сохранять промежуточные состояния
- Перегружаю функцию, которую хочу исследовать
- Сохраняю промежуточные состояния в виде структур с параметрами.

```
class RemittanceViewModelSpy: RemittanceViewModel {

    lazy var loadingHistory: [CurrencyRateRequest] = []

    override func load(amount: Decimal, amountSource: AmountSource) async throws {
        try await super.load(amount: amount, amountSource: amountSource)

        let loanAmount = loan.map { String($0.double) } ?? "null"

        let event = CurrencyRateRequest(
            amount: amount.double,
            amountSource: amountSource,
            loanAmount: loanAmount)

        loadingHistory.append(event)
    }
}
```

Чтобы протестировать это достаточно в тесте написать `assertInlineSnapshot(of: sut.loadingHistory, as: .dump)` и запустить тест. При прогоне тест упадет, но **сам допишет** какие значения были во время выполнения. При следующем прогоне он сравнит новое значение с предыдущим и если они не изменились, то тест прошел.  


```swift
assertInlineSnapshot(of: sut.loadingHistory, as: .dump) {
    """
    ▿ 2 elements
    ▿ CurrencyRateRequest
        - amount: 200.0
        - amountSource: AmountSource.from
        - loanAmount: "null"
    ▿ CurrencyRateRequest
        - amount: 200.0
        - amountSource: AmountSource.loan
        - loanAmount: "100.0"
    """
}
```

Причем получается, что в этом тесте я проверяю не конечные запросы, а с какими данными эти запросы сформируются. В этом примере такой детализации было достаточно чтобы и много текста не сгенерировать, но и точно проверить.  

@Comment {
    показать на видео как кейсы дописываются сами
}

Если вы хотите обновить слепок, то просто удалите все что в фигурных скобках и запустите тест заново.

@Comment {
    рассказать как все затирать
}

Походим образом можно тестировать какие состояния прошла вьюшка (загрузка + данные | фейл), но это разберем позже в главе <doc:3-1-ui-states>

## Кастомные стратегии

@Comment {
    Добавить
    
    Пример про сравнение картинок для чеков. 
}

## Снепшот-интерфейса

Подробнее про это в статье <doc:3-3-preview-prefire>

## Подход «снепшот всех контрактов» помогает коммуникациям в команде

Обычно результаты тестирования интересны только разработчикам, но вот снепшот-тесты позволяют упростить коммуникацию в команде:
- Снепшот сетевых запросов можно обсудить с бэкендщиком, чтобы отловить ошибку
- Скриншоты можно показать дизайнеру, чтобы сверить верстку с Figma
- Снепшот аналитики поверх сценария позволит аналитику лучше понять всех ли данных достаточно. 

Таким образом цикл разработки замыкается: команда договаривается о разных контрактах в начале задачи (API, дизайн, аналитика) и результаты работы приложения принимаются тоже в виде снепшотов этих контрактов.  

@Comment {
    рассказать про примеры:
    - версионирование структуры файлов
    - аналитика
}

> Tip: старайтесь как можно больше тестов свести к снепшот-тестированию. Так вы сможете больше проверок переложить на программу
