# UI-тесты

UI-тестирование используют все крупные компании и, иногда, это становится главным способом тестирования приложения. Разберем особенности тестирования через UI

## Цель тестирования через UI

Давайте будем переводить UI-testing как «тестирование через UI», а не как «тестирование интерфейса», потому что именно интерфейс протестировать не особо получается и с этим лучше справится <doc:3-0-screenshot-testing>.

Плюсы:
- Тестируем end-to-end, вместе с бэкендом 
- Очень близко к тому как это нажимает пользователь
- Тестирует итоговый интерфейс, который показался в сценарии. Раньше роутер фейкали, а здесь его тестируем.
- Устойчивы к рефакторингу
- Тестируют модули в связке. 

Минусы:
- Очень медленные, потому что приходится поднимать весь код, использовать поиск по интерфейсу и реальную сеть. 
- Из-за скорости не дают быстрый фидбек, скорее проверяют что в целом 
- Нужно писать сильно отдельно: разработчики забывают идентификаторы, потому что тесты пишут тестировщики. В итоге разработке не пользуется этими тестами, а цель тестов — сократить регресс-тестирование. 
- Нестабильные, а разработчиков к стабилизации сложно привлечь. 

## Page-Object

Многие сценарии проходят через одни и те же экраны, поэтому стоит описать экраны, которые есть у вас в приложениях, а в тестах обращатсья к этим оберткам. Так после изменение на одном экране можно будет изменить обращение к селекторам в одном месте. 

```swift
func test_fullPath() {
    app.launch(keepAuthData: false)

    signIn.startOnboarding()
    signIn.authorize()
    userInfo.inputHomer()
    app.assertBackButtonExists()
    addressPage.fillAddress()

    expectKYCScreen()
}
```

Пример пейдж-обжекта, который обращается к селекторам:
```swift
class PasscodePage: Page {

    // MARK: scenario
    func waitAndCreate(_ passcode: String = "123456") {
        expectPasscodeCreation()
        inputPasscode(passcode)
        inputPasscode(passcode)
    }

    func waitAndConfirm(passcode: String = "123456") {
        expectPasscodeConfirmation()
        inputPasscode(passcode)
    }

    // MARK: functions
    func expectPasscodeCreation() {
        app.expectText("Create passcode")
    }

    func expectPasscodeConfirmation() {
        app.expectText("Confirm passcode")
    }

    func inputPasscode(_ passcode: String) {
        for char in passcode {
            app.buttons["\(char)"].tap()
        }
    }
}
```

@Comment {
    тут хватает каких-то моих функций
}

## Дерево доступности

@Comment {
    рассказать из-за чего строится описание экрана
}


## Стоит ли мокать сеть

Соблазн ускорить и стабилизировать тесты за счет мока сети. Если сделать автозапись подход рабочий + негативные тесты легко проверить будет, но это нужно постоянно обновлять. Если разработчики за UI-тестами не следят, то QA будут очень много времени тратить на исправление тестов (и это еще надо понять что не так: контракт устарел, код обновился или тест сломался).

В противовес этому можно улучшать стабильность тестового окружения. 

## Тулинг: TestOps, [Emcee от Avito](https://github.com/avito-tech/Emcee)

@Comment {
    
}

