# Архитектура тестируемой навигации

Для тестирования сценариев надо научиться тестировать переходы между экранами и передачу данных. Но сначала надо архитектурно решить как мы к этому придем. 

## Проблема: интерфейс пишут раньше чем закладывают архитектуру, от чего страдает навигация. 

Многие пришли в iOS потому что нравится интерфейс, можно быстро сделать красиво, а потом разобраться с остальным. В итоге есть общее коллективное искажение: архитектура всегда отстой, навигация едва работает, тесты ваще никто не пишет, многомодульность есть только в больших проектах. 

Давайте на примере раскручивать задом наперед и начнем с теста! Точнее, с понимания задачи. 

@Image(source: OnboardingFlow) {}

Вот мне надо сделать онбординг. По идее все просто: 
- Вводишь телефон,
- Подтверждаешь смс,
- Вводишь пасскод два раза,
- Заполняешь данные пользователя на парочке экранов,
- Проходишь KYC (это когда документы фоткаешь и себя на видео снимаешь),
- Ждешь когда документы проверят,
- Переходишь в основное приложение.

Я описал кратко, но даже так уже давит, а там под 30 экранов надо сделать с ветвлениями:
- После ввода телефона может быть логин повторного пользователя и онбординг не нужен, сразу переходим в главное приложение.
- На повторном запуске восстановиться можно на любой экран.
- Повторный логин должен уметь восстанавливаться на нужный шаг.
- Есть несколько опциональных экранов.
- С начала проектирования этой части количество экранов удвоилось и что-то постоянно меняется. 

Т.е. уже выглядит как дурь, которую надо протестировать, но там ведь еще и переходы между экранами анимированные, данные надо прокидывать между экранами и т.п. 

При этом у нас есть в целом понятный сценарий относительно запросов и контрактов (смотрите на зеленые квадратики и белые стрелочки):
- Запросить смс на телефон. 
- Подтвердить кодом из смс.
- Сохранить в сторедж пасскод.
- Узнать есть ли такой пользователь, если он новый, то продолжить онбординг.
- Собрать разные данные и отправить их бэкенду разом.

@Image(source: OnboardingScheme) {}

А вот теперь синии квадратики: все это размано между разными экранами и их вьюмоделями. При этом деление на вьюмодели может быть очень условным: 
- Сегодня мы отправляем запрос на смс на экране телефона, а завтра перенесли на экран смс, потому что так повторный код проще запрашивать и UX поприкольней. 
- Сегодня собираем 5 полей данных пользователя на одном экране, а завтра поделили на два
- Сегодня не надо подтверждать емейл, а завтра уже надо, потому что так регулятор требует. 

Т.е. все деление на вьюмодели это уже детали реализации. 

Получается, что:
- у нас есть один большой сценарий, который надо пройти, 
- он может чуть-чуть ветвится для разных людей, это добавит еще пару тестов.
- многие из экранов должны обрабатывать ошибки которые мешают пройти дальше, но на основной сценарий это не влияет
- и еще несколько тестов на восстановление в разные точки сценария. 

В итоге я хочу вот такой интеграционный тест на сценарий внутри модуля онбординга:
￼
```swift
@Test
func whenPassOnboarding_shouldCreateUser() async throws {
    sut.start()

    try await viewModel(route: \.phone).pass()
    try await viewModel(route: \.sms).pass()
    try await viewModel(route: \.passcode).pass()
    try await viewModel(route: \.userInfo).pass()
    try await viewModel(route: \.email).pass()
    try await viewModel(route: \.address).pass()
    try await passKYC()

    let pollingVM = try await viewModel(route: \.polling)
    await pollingVM.pass ()

    // Modal screen inside PollingView
    try await #require(pollingVM.terms).pass() 

    #expect (userIsReady == true)
｝
```

Тут выходит довольно интересная штука:
- Тест ультракороткий и обалдеть сколько охватывает. Аргумент «надо много времени на тесты» отваливается сам собой (а в хорошкую архитектуру для такого теста грех не инвестировать, остальное тоже проще станет)
- Он верхнеуровневый: я вытаскиваю вьюмодели (для SwiftUI это почти уровень интерфейса) и делаю что надо для этого экрана в функции `pass()`
- Он устойчив к изменениям кода: можно сильно поменять любую вьюмодель или архитектуру, но сам тест не изменится пока бизнес-требования не пересмотрятся. Остальное правится через DSL.
- Он шаблонный: вьюмодели и вытаскиваются и проходят одинаково почти везде
- Он контролируется через зависимости: сеть в тесте настоящая, хранилище инмемори, аналитика снепшотится, замокан только KYC-фреймворк.
- Поверх такого теста легко исследовать разные штуки: перформанс, профиль сети, записи на диск, общее потребление памяти, утечки и т.п.
- В стартапе постоянно все меняется? Ну да, добавляются новые шаги, меняется порядок. Сильно ли от этого изменится тест? Нет, поменяется лишь пара строк. 

В итоге по заветам TDD: вот такой тест я хочу, давайте подкрутим код под это. 


## Описание навигации

Раскручиваем состояние из теста дальше. 

Для любого экрана хочу видеть вьюмодель, которая полностью описывает состояние экрана. Тогда получается, что основной сценарий онбординга это буквально перечень всех экранов и их вьюмоделей. А Раз навигация в нав-контроллере, то их можно сложить их в единый массив и слой навигации на уровне данных готов!

Макрос `@CasePathable` позволяет использовать всякие `.is` и `[case: \.phone]` для тестов. 

```swift
@CasePathable
enum OnboardingRoute {
    case phone (PhoneViewModel)
    case sms(SMSViewModel)
    case passcode (PasscodeViewModel)
    case userData (UserDataViewModel)
    case email(EmailViewModel)
    case address(AddressViewModel)
    case addressLookup(AddressViewModel)
    case addressManual(AddressManualViewModel)
    case geoAndKYC(GeolocationAndKYCViewModel)
    case shareCode (ShareCodeViewModel)
    case polling(PollingViewModel)
    case `final`(OnboardingFinalViewModel)
｝

// MARK: - Navigation
var path: [OnboardingDestination] = []

public func navigate(to destination: OnboardingDestination) {
    path.append (destination)
}

func resetNavigation() {
    path = []
}
```

`UIKit` так не работает, а вот `SwiftUI` очень даже! Начиная с iOS 16 `NavigationView` работает с массивом и может отслеживать появление объектов разных типов, красиво! Для каждого модуля может быть своя енумка, но все напихивают данные в единый стек. Для более старых iOS можно использовать бэкпорт в виде `NavigationStackController`: он работает через `UIKit обертку`, но тоже умеет обсервить. 

```swift
public var body: some View {
    WithPerceptionTracking {
        NavigationStack(path: $coordinator.path) {
            OnboardingStartView(next: coordinator.navigateToPhone)
                .navigationDestination(
                    for: OnboardingDestination.self, 
                    destination: destinationView)
        }
    }
}
```

Стандартная модальная навигация `SwiftUI` предполагает, что для каждого экрана должна быть своя переменная. С `@CasePathable` мы тоже можем в одном enum описать все возможные состояния переходов для одного экрана и хранить его в одной переменной, потому что за раз все равно может показаться только одна модалка. Ну и тестировать такое полегче. 

```swift
import SwiftNavigation

@Observable
class FeatureModel {
    var destination: Destination?

    @CasePathable
    enum Destination {
        case addItem (AddItemModel)
        case deleteItemAlert
        case editItem (EditItemModel)
    }
}

import SwiftUINavigation

class SomeViewController: UIViewController {

func viewDidLoad() 
    super.viewDidLoad()

    sheet(item: $model.destination.addItem) { addItemModel in
        AddItemView(model: addItemModel)
    }

    alert("Delete?", isPresented: Binding($model.destination.deleteItemAlert)) {
        Button ("Yes", role: destructive) { /* ... */ }
        Button("No", role: -cancel) {}
    }

    navigationDestination(item: $model.destination.editItem) { editItemModel in
        EditItemView(model: editItemModel)
    }
}
```

В итоге получается вот такая схема: на уровне данных можно полностью отделить сценарий, его походы в сеть и навигацию, он будет складывать итоговые вьюмодельки в словарь, это все будет обсервиться как для навигации так и на уровне одного экрана. Мне такой подход очень понравился, пишу на нем. 

@Image(source: ResultScheme)
